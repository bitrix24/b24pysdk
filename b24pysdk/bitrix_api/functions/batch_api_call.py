from collections import OrderedDict
from operator import itemgetter
import time
from typing import Union, List, Tuple, Any, Iterable, Dict, Text

from ...utils.types import B24BatchRequestData, RawStringParam

from ..config import SdkConfig

from .api_call import api_call
from .convert_params import encode_methods


class BatchResultDict(OrderedDict):
    @property
    def all_ok(self) -> bool:
        return not any(self.iter_errors())

    def iter_errors(self) -> Iterable[Tuple[Text, Any]]:
        for name, res in self.items():
            if res["error"] is not None:
                yield name, res["error"]

    @property
    def errors(self) -> Dict[Text, Any]:
        return OrderedDict(self.iter_errors())

    def iter_successes(self) -> Iterable[Tuple[Text, Any]]:
        for name, res in self.items():
            if res["error"] is None:
                yield name, res

    @property
    def successes(self) -> Dict[Text, Any]:
        return OrderedDict(self.iter_successes())

    def __repr__(self):
        return "{}({}, all_ok={})".format(
            type(self).__name__,
            dict.__repr__(self),
            self.all_ok,
        )


def _group_by_n(methods: Dict[Text, RawStringParam], n: int = 50) -> List[Dict[Text, RawStringParam]]:
    """Slices dictionary into chunks of size n.

    Args:
        methods: dictionary with all methods sent to batch_api_call
        n:  maximum size of resulting chunks
    Returns:
        methods grouped in chunks of size n
    """
    assert n > 0
    methods_flat = list(methods.items())
    return [dict(methods_flat[i:i + n]) for i in range(0, len(methods), n)]


def _generate_method_names(methods: Iterable[B24BatchRequestData]) -> Dict[Text, B24BatchRequestData]:
    """
    If methods were provided without identifiers, returns them with autogenerated ones

    Args:
        methods: collectuin of rest api methods with their params without identifiers
    Returns:
        dict of identifier: (method, params) pairs
    """
    return {f"data_{i}": method for i, method in enumerate(methods)}


def batch_api_call(
        methods: Union[Dict[Text, B24BatchRequestData], Iterable[B24BatchRequestData]],
        domain: Text,
        *,
        auth_token: Text,
        halt: int = 0,
        chunk_size: int = 50,
        is_webhook: bool = False,
        timeout: int = SdkConfig().default_timeout,
) -> BatchResultDict:
    """
    """
    if chunk_size < 1 or chunk_size > 50:
        raise ValueError("chunk_size must be within the range [1, 50]")

    if not methods:
        return BatchResultDict()

    methods: Dict[Text, B24BatchRequestData] = methods if isinstance(methods, dict) else _generate_method_names(methods)
    encoded_methods = encode_methods(methods)
    grouped_methods = _group_by_n(encoded_methods, n=chunk_size)

    responses = BatchResultDict()

    def add_response(part_request_names: Iterable[Text], part_resp: Dict):
        res = part_resp["result"]
        for key in ("result", "result_error", "result_time",
                    "result_total", "result_next"):
            if key not in res:
                res[key] = {}
            elif isinstance(res[key], list):
                res[key] = {str(i): v for i, v in enumerate(res[key])}
        for req_name in part_request_names:
            responses[req_name] = dict(
                result=res["result"].get(req_name),
                error=res["result_error"].get(req_name),
                time=res["result_time"].get(req_name),
                total=res["result_total"].get(req_name),
                next=res["result_total"].get(req_name),
            )

    for method_group in grouped_methods:
        data = api_call(
            domain=domain,
            api_method="batch",
            auth_token=auth_token,
            params={
                "cmd": method_group,
                "halt": halt,
            },
            is_webhook=is_webhook,
            timeout=timeout,
        )

        try:
            operating = max(data["time"]["operating"], *map(itemgetter("operating"), data["result"]["result_time"].values()))
            if operating > 300:
                time.sleep(operating - 300)
        except KeyError:
            pass

        add_response(part_request_names=method_group.keys(), part_resp=data)

    return responses
